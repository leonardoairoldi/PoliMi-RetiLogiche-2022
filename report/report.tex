%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{microtype}
\usepackage{appendix}
\usepackage{csquotes}
\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{caption}
\usepackage{tikz}
\usepackage{pdfpages}
\usepackage[hidelinks]{hyperref}

\usetikzlibrary{arrows,automata, positioning}
\tikzset{
  ->, % makes the edges directed
  >=stealth', % makes the arrow heads bold
  node distance=4cm, % specifies the minimum distance between two nodes. Change if necessary.
  every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
  initial text=$ $, % sets the text that appears on the start arrow
}

\usepackage{import}

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Prova Finale di Reti Logiche} % Title
\author{Leonardo Airoldi} % Author name
\date{A. A. 2021-22}

\begin{document}
\maketitle % Insert the title, author and date


\tableofcontents
\newpage



% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

%----------------------------------------------------------------------------------------
%	INTRODUZIONE
%----------------------------------------------------------------------------------------

\chapter{Introduzione}


La specifica della Prova finale (Progetto di Reti Logiche) 2021 richiede di implementare un \textbf{codificatore convoluzionale} usando il linguaggio VHDL.\\
Un codificatore convoluzionale è un dispositivo che tramite l'applicazione di un \textit{codice convoluzionale} codifica uno stream di bit in ingresso in uno stream di bit in uscita ridondante che permette a un dispositivo che legge lo stream codificato di risalire allo stream originale anche in presenza di errori applicando tecniche di \textit{error-correction}.
Codificatori convoluzionali elettronici sono molto comuni nell'ambito delle telecomunicazioni, in quanto conferiscono a una rete un certo grado di robustezza: un dispositivo ricevente può ricostruire il segnale trasmesso, che potrebbe risultare corrotto a causa del rumore sulla linea, senza richiedere un ulteriore invio dell'informazione.

\section{Specifiche}
Nel caso specifico di questo progetto, è richiesto lo sviluppo di un circuito integrato con le seguenti caratteristiche: 
\begin{enumerate}
\item il \textit{codice convoluzionale} ha \textbf{tasso di trasmissione} $\frac{1} {2}$.
\item si interfaccia con una memoria sincrona a word di 8bit e indirizzi a 16bit.
\item lo stream in ingresso è di dimensione $n$ words memorizzate a partire dall'indirizzo \texttt{0x01}.
\item la dimensione dello stream è memorizzata all'indirizzo \texttt{0x00} ed è al massimo di 255 word.
\item il dispositivo viene sempre inizializzato con un segnale di \texttt{reset}.
\item la computazione inizia al segnale di \texttt{start} e termina quando il dispositivo alza il segnale \texttt{done}. Il dispositivo deve essere in grado di gestire computazioni successive senza aver bisogno di un segnale di \texttt{reset}. Si presuppone che il segnale di \texttt{start} rimanga alto durante tutta la computazione e che non possa essere rialzato prima che il segnale di \texttt{done} sia stato riportato a \texttt{0}.
\item il dispositivo deve funzionare con un periodo di clock di almeno \texttt{100ns}
\end{enumerate}

\section{Strumenti}
Il progetto sarà sviluppato in \textbf{VHDL} (VHSIC Hardware Description Language) che permette di descrivere circuiti integrati.
Per la simulazione e la sintesi della scheda il software utilizzato è \textbf{Xilinx Vivado} (\textit{v2021.1}).
Il dispositivo sarà poi implementato su una \textbf{FPGA Artix 7 \texttt{xc7a200tfbg484-1}}.

\section{Esempio}



%----------------------------------------------------------------------------------------
%	ARCHITETTURA
%----------------------------------------------------------------------------------------

\chapter{Architettura}
Il dispositivo è stato implementato come una macchina a stati che controlla un datapath, che si interfaccia con diversi componenti più piccoli. La scelta di dividere il progetto moduli più piccoli è stata presa per non rendere troppo complessa e articolata la gestione del dispositivo nella sua interezza. In questo modo la macchina a stati si limita a gestire la comunicazione e coordinazione dei vari componenti, che eseguono ciascuno una funzione definita anch'essa da una macchina a stati interna.

\section{Serializzatore}

Il \textbf{serializzatore} è il componente addetto alla serializzazione in un flusso continuo di bit dei byte caricati dalla ram.
Il serializzatore si interfaccia, oltre al segnale di \textit{clock} e al segnale di \textit{reset}, con il segnale di ingresso da serializzare \texttt{[input:8bit]} e dal segnale di controllo \textit{start}. Produce in uscita un segnale di \texttt{[output:1bit]} che corrisponde al flusso serializzato del byte in input e un segnale di \textit{done} che indica la fine della serializzazione.

Al segnale di \texttt{start} della serializzazione il componente passa dallo stato \texttt{STOPPED} allo stato attivo. Quando il componente è attivo produce in uscita per \textbf{due clicli di clock} l'\textit{n-esimo} bit del segnale in ingresso, incrementando poi il contatore per produrre in uscita l'\textit{n+1 esimo} bit del byte in ingresso nei prossimi due cicli di clock. La serializzazione termina quando il contatore interno raggiunge il valore \texttt{111}: il registro viene incrementato tornando quindi a \texttt{0} ma il serializzatore torna nello stato \texttt{STOPPED}, che alza il segnale di \texttt{done} a \texttt{1}.

Il flusso in uscita ha periodo di due cicli di clock in quanto al convolutore server produrre due bit sequenzialmente in uscita per ogni bit in entrata. In questo modo la velocità di serializzazione è ridotta della metà ma il convolutore riesce a produrro il flusso risultante sullo stesso ciclo di clock della macchina.

\includegraphics[scale = 0.45]{schematics/serializer.pdf}

\section{Convolutore}
Il \textbf{convolutore} è il componente che emula il comportamento della macchina a stati del convolutore convoluzionale. E' stato realizzato seguendo il modello ad \textit{automa a stati finiti (\textbf{FSM})}.
Il componente si interfaccia (oltre al segnale di \textit{clock} e al segnale di \textit{reset}) a un segnale di reset interno e a un segnale di \textit{pause}. Questo permette al convolutore di fermare la propria macchina a stati ignorando l'\textit{input} ma mantenendo comunque lo stato corrente della macchina. Questo stato di pausa viene utilizzato per attendere i caricamenti da e verso la memoria RAM che richiedono qualche ciclo di clock per caricare/scaricare i registri nella memoria e viceversa. 

L'automa produce due bit in serie per ogni bit ricevuto in ingresso: per questo è fonadmentale che il serializzatore mantenga per due cicli di clock il bit in ingresso. L'automa quindi possiede due stati per ogni macro-stato del convolutore convoluzionale, che corrispondono allo stato in cui l'uscita è settata a pk1 e l'uscita è settata a pk2.

La scelta di implementare il componente in questo modo è stata presa per rispettare le specifiche di progetto:
\begin{displayquote}
  \textit{''Il flusso Y è ottenuto come concatenamento alternato dei due bit di uscita''}
\end{displayquote}

Avendo un convolutore implementato come \textbf{entity separata a sè stante} è possibile utilizzare il componente come da specifica anche in altri progetti. Se per esempio si fosse scelto di gestire l'output del convolutore come una coppia di segnali pk1 e pk2 si sarebbe ridotto il tempo di computazione ma la specifica riguardante il flusso di uscita di dimensione di 1bit sarebbe stata violata.

\includegraphics[scale = 0.45]{schematics/convolutor.pdf}

\section{Parallelizzatore}
Il \textbf{parallelizzatore} è il componente addetto alla raccolta del flusso in uscita dal convolutore e alla sua memorizzazione in un registro interno. Questo permette di \textit{impacchettare} il flusso d'uscita in byte in modo da essere scritti sulla memoria ram. 
Dato che per questa configurazione del convolutore a \textbf{ogni byte in ingresso} corrispondono \textbf{2 byte in uscita}, questo componente è stato progettato con un registro interno a \textbf{16 bit} in modo da poter memorizzare i 2 byte in uscita dall'elaborazione di un singolo byte e gestire poi il caricamento delle 2 parole sulla RAM. 

Il parallelizzatore si interfaccia con un ingresso \texttt{[input:1bit]} e produce un'uscita \texttt{[output:8bit]}, selezionabile tramite un \textbf{multiplexer}, che seleziona sull'uscita i bit \texttt{[0-7]} e \texttt{[8-15]} del registro interno.

Al segnale di \texttt{start} il componente passa dallo stato \texttt{STOPPED} allo stato \texttt{ACTIVE}. Quando il componente è attivo memorizza il bit di \textbf{ingresso} nell'\textit{n-esimo} bit del registro interno, incrementando poi il contatore per il prossimo ciclo di clock. La parallelizzazione termina quando il contatore interno raggiunge il valore \texttt{1111}: il registro viene incrementato tornando quindi a \texttt{0} e il parallelizzatore torna nello stato \texttt{STOPPED}, tenendo però comunque memorizzati i valori nel registro. A questo punto la macchina a stati entra negli stati di \textit{caricamento in RAM}, dove carica nel registro di uscita in ordine il primo byte e il secondo nel registro di uscita, da cui poi il dato vene caricato sulla memoria.

\includegraphics[scale = 0.45]{schematics/parallelizer.pdf}

\section{Datapath}
Il \textbf{datapath} è l'entità che \textbf{fornisce ai vari moduli un'interfaccia} per comunicare tra loro o con la \textbf{memoria RAM}.
Per permettere le comunicazioni tra i vari moduli del dispositivo, istanziati nella macchina a stati (\textit{project\_reti\_logiche}), al datapath sono passati i segnali rappresentanti \textit{dati} (mentre non sono passati quelli di controllo, di responsabilità della macchina a stati) dei vari componenti, che poi vengono connessi all'interno del datapath.

Il datapath contiene inoltre i componenti per interfacciarsi con la RAM e dei registri di supporto per la FSM.
 
\textbf{Registri in out.} Nella fase di lettura dalla memoria ram il dato viene letto e caricato in un registro \textit{reg\_in}. Nella fase di scrittura invece il dato sarà prelevato dal registro \textit{reg\_out}. Entrambi i registri sono da 8bit e sono connessi rispettivamente al serializzatore e al parallelizzatore. Il loro caricamento viene gestito dalla FSM.

\textbf{Registro words.} Nella fase di avvio del dispositivo viene letto all'indirizzo 0 della memoria il numero di byte da cui è formato lo stream di ingresso. Questo valore è memorizzato all'interno del registro \textit{reg\_words}, di 8bit in quanto la dimensione massima dello stream in ingresso è di 255 parole. Il suo caricamento è gestito dalla FSM.

\textbf{Registro count.} Durante l'esecuzione è necessario memorizzare lo stato di avanzamento in modo da sapere a quale indirizzo della RAM accedere per leggere o scrivere dati. Questo resgistro memorizza al suo interno \textit{l'indirizzo} della cella di memoria di \textit{read} a cui si sta puntando. Per esempio se si sta leggendo la terza parola dello stream nel registro sarà presente il valore \texttt{0x0003} in quanto lo stream è memorizzato a partire dall'indirizzo \texttt{0x0001}. E' un registro a 16bit e il suo caricamento e incremento è gestito dalla FSM.

\textbf{Done comparator.} Per rilevare la fine dell'elaborazione nel datapath è presente un comparatore. Esso effettua un controllo che porta un segnale di \textit{done} interno a 1 se il valore contenuto all'interno del registro di \textit{count} supera il numero di parole. Questo sfrutta il fatto che il numero della parola corrente corrisponde al contenuto del registro \textit{count}, in quando l'indirizzo della parola n-esima è n. Inoltre, se dovessimo essere nel caso in cui la lunghezza dello stream fosse 255, il confronto funzionerebbe ancora perchè fino a 255 il processo continuerebbe regolarmente mentre al raggiungimento di 256, valore possibile nel registro degli indirizzi a 16bit \textit{count}, il confronto finirebbe correttamente per segnalare la fine dell'esecuzione.
\begin{verbatim}
  if mux_count <= ("00000000" & reg_words) then
            o_done_signal <= '0';
        else
            o_done_signal <= '1';
\end{verbatim}

\textbf{Multiplexer read write.} Il registro \textit{count} non è direttamente collegato con il segnale \textit{address} della memoria RAM. Questo perchè in scrittura devono essere utilizzati gli indirizzi contigui partendo dall'indirizzo 1000. Questo multiplexer permette di selezionare quale indirizzo viene passato al segnale di indirizzo della memoria:
\begin{verbatim}
  if i_rst = '1' or mux_rw_addr_sel = "00" or mux_rw_addr_sel = "11" then
            o_address <= reg_count;
        elsif mux_rw_addr_sel = "01" then
            o_address <= (mux_count + mux_count) + "0000001111100110";
        else --if mux_rw_addr_sel = "10" then
            o_address <= (mux_count + mux_count) + "0000001111100111";
        end if;
\end{verbatim}
Il mux seleziona di default il contenuto del registro \textit{count} usato in lettura dello stream. Per la scrittura dei due byte corrispondenti all'elaborazione dell'n-esima parola, viene selezionato l'indirizzo $2n + 998$ per il primo byte e $2n + 999$ per il secondo. Questo permette di scrivere nell'indirizzo giusto i due byte derivati dall'elaborazione dell'n-esimo byte. Per esempio, la convoluzione terza parola verrà scritta negli indirizzi \texttt{1004 1005}, in quanto la prima parola è scritta all'interno di \texttt{1000 1001} e la seconda in \texttt{1002 1003}, come da specifica.

\includegraphics[scale = 0.45]{schematics/datapath.pdf}

\section{Macchina a stati}
Il progetto è tutto contenuto all'interno della entity Vivado \textbf{project\_reti\_logiche}. Questa contiene al suo interno tutti i \textbf{components} del dispositivo (serializer, convolutor, parallelizer e datapath) e implementa tramite tre \textbf{process} (\textit{FSM\_STATE\_CHANGE, FSM\_FLOW, FSM\_OUT}). Questa FSM permette di controllare il flusso d'esecuzione di tutto il dispositivo portando i segnali di controllo ai valori corretti in base allo stato in cui ci si trova.

\begin{figure}[ht] % ’ht’ tells LaTeX to place the figure ’here’ or at the top of the page
  \centering % centers the figure
  \begin{tikzpicture} [state/.style={circle, draw, minimum size=2cm, thick, font=\tiny, fill=gray!10}]
    \node[state, initial] (RESET) {$RESET$};
    \node[state, right of=RESET] (READ_WORDS_RAM_REQUEST) {$RWR\_REQ$};
    \node[state, right of=READ_WORDS_RAM_REQUEST] (READ_WORDS_RAM_READ) {$RWR\_READ$};
    \node[state, below of=READ_WORDS_RAM_READ] (READ_RAM_REQUEST) {$RR\_REQ$};
    \node[state, left of=READ_RAM_REQUEST] (READ_RAM) {$READ\_RAM$};
    \node[state, below of=READ_RAM] (SERIALIZE) {$SERIALIZE$};
    \node[state, right of=SERIALIZE] (LOAD_FROM_PAR) {$LOAD\_PAR$};
    \node[state, below of=LOAD_FROM_PAR] (WRITE_RAM_1) {$WRAM\_1$};
    \node[state, below of=WRITE_RAM_1] (WRITE_RAM_2) {$WRAM\_2$};
    \node[state, left of=WRITE_RAM_2] (WRITE_RAM_WAIT) {$WR\_WAIT$};
    \node[state, left of=WRITE_RAM_WAIT] (DONE) {$DONE$};
    
    \draw (RESET) edge[loop above] node{$start = 0$} (RESET)
          (RESET) edge[above] node{$start = 1$} (READ_WORDS_RAM_REQUEST)
          
          (READ_WORDS_RAM_REQUEST) edge[above] node{} (READ_WORDS_RAM_READ)
          (READ_WORDS_RAM_READ) edge[above] node{} (READ_RAM_REQUEST)

          (READ_RAM_REQUEST) edge[bend right=38] node {$o\_done\_signal = 1$} (DONE)
          (READ_RAM_REQUEST) edge[above] node{$o\_done\_signal = 0$} (READ_RAM)

          (READ_RAM) edge[above] node{} (SERIALIZE)

          (SERIALIZE) edge[loop below] node{$ser\_done = 0$} (SERIALIZE)
          (SERIALIZE) edge[above] node{$ser\_done = 1$} (LOAD_FROM_PAR)

          (LOAD_FROM_PAR) edge[above] node{} (WRITE_RAM_1)
          (WRITE_RAM_1) edge[above] node{} (WRITE_RAM_2)
          (WRITE_RAM_2) edge[above] node{} (WRITE_RAM_WAIT)
          (WRITE_RAM_WAIT) edge[above] node{} (READ_RAM_REQUEST)

          (DONE) edge[loop left] node{$start=1$} (DONE)
          (DONE) edge[above] node{$start=0$} (RESET)
          ;
  \end{tikzpicture}
  \caption{Caption of the FSM}
  \label{fig:my_label}
  \end{figure}
\begin{tikzpicture}
  
\end{tikzpicture}

%----------------------------------------------------------------------------------------
%	RISULTATI SPERIMENTALI
%----------------------------------------------------------------------------------------

\chapter{Risultati sperimentali}
Il dispositivo progettato è stato sintetizzato e testato con il tool Vivado di Xilinx. Vengono riportate ora le analisi sugli aspetti di sintesi del dispositivo e sui test effettuati su di esso.

\section{Sintesi}
La sintesi è eseguita con un constraint sul periodo di clock di \textbf{100ns} e con una fpga target \textbf{FPGA Artix 7 \texttt{xc7a200tfbg484-1}}.
\subsection{Componenti}
Il report di sintesi riassume l'elenco dei componenti della FPGA utilizzati per sintetizzare il dispositivo.

\begin{verbatim}
+-------------------------+------+-------+------------+-----------+-------+
|        Site Type        | Used | Fixed | Prohibited | Available | Util% |
+-------------------------+------+-------+------------+-----------+-------+
| Slice LUTs*             |  109 |     0 |          0 |    134600 |  0.08 |
|   LUT as Logic          |  109 |     0 |          0 |    134600 |  0.08 |
|   LUT as Memory         |    0 |     0 |          0 |     46200 |  0.00 |
| Slice Registers         |   81 |     0 |          0 |    269200 |  0.03 |
|   Register as Flip Flop |   81 |     0 |          0 |    269200 |  0.03 |
|   Register as Latch     |    0 |     0 |          0 |    269200 |  0.00 |
| F7 Muxes                |    1 |     0 |          0 |     67300 | <0.01 |
| F8 Muxes                |    0 |     0 |          0 |     33650 |  0.00 |
+-------------------------+------+-------+------------+-----------+-------+
\end{verbatim}

Si può notare come tutti i registri utilizzati siano    \textbf{sincroni} (flip flop).

\subsection{Timing}
Il report di timing riassume i parametri della scheda in relazione al segnale di clock

\begin{verbatim}
Slack (MET) :             95.783ns  (required time - arrival time)
  Source:                 DATAPATH0/reg_count_reg[3]/C
                            {rise@0.000ns fall@50.000ns period=100.000ns}
  Destination:            FSM_onehot_cur_state_reg[4]/D
                            {rise@0.000ns fall@50.000ns period=100.000ns}
  Path Group:             clock
  Path Type:              Setup (Max at Slow Process Corner)
  Requirement:            100.000ns  (clock rise@100.000ns - clock rise@0.000ns)
  Data Path Delay:        4.066ns  (logic 1.496ns (36.793%)  route 2.570ns (63.207%))
  Logic Levels:           4  (CARRY4=2 LUT4=1 LUT6=1)
  Clock Path Skew:        -0.145ns (DCD - SCD + CPR)
    Destination Clock Delay (DCD):    2.100ns = ( 102.100 - 100.000 ) 
    Source Clock Delay      (SCD):    2.424ns
    Clock Pessimism Removal (CPR):    0.178ns
  Clock Uncertainty:      0.035ns  ((TSJ^2 + TIJ^2)^1/2 + DJ) / 2 + PE
    Total System Jitter     (TSJ):    0.071ns
    Total Input Jitter      (TIJ):    0.000ns
    Discrete Jitter          (DJ):    0.000ns
    Phase Error              (PE):    0.000ns
\end{verbatim}

Si può notare come lo \textbf{slack} (parametro che indica il tempo tra il delay massimo della logica combinatoria e il prossimo rising-edge del ciclo di clock) sia particolarmente elevato. Questo a grazie al delay della logica combinatoria (\textbf{4.066ns}) che risulta più di un ordine di grandezza inferiore al periodo del ciclo di clock (100ns).
Questo dato indica quindi che la scheda sarebbe in grado di girare a 10 volte la velocità attuale, ovvero con un ciclo di clock di periodo 10ns (100Mhz).

%----------------------------------------------------------------------------------------
%	CONCLUSIONE
%----------------------------------------------------------------------------------------

\chapter{Conclusione}


\end{document}