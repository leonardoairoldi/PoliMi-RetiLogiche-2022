%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{microtype}
\usepackage{appendix}
\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage{siunitx} % Provides the \SI{}{} and \si{} command for typesetting SI units
\usepackage{graphicx} % Required for the inclusion of images
\usepackage{natbib} % Required to change bibliography style to APA
\usepackage{amsmath} % Required for some math elements 
\usepackage{caption}
\usepackage{tikz}
\usepackage{pdfpages}
\usepackage[hidelinks]{hyperref}

\usetikzlibrary{arrows,automata, positioning}

\usepackage{import}

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------

\title{Prova Finale di Reti Logiche} % Title
\author{Leonardo Airoldi} % Author name
\date{A. A. 2021-22}

\begin{document}
\maketitle % Insert the title, author and date


\tableofcontents
\newpage



% If you wish to include an abstract, uncomment the lines below
% \begin{abstract}
% Abstract text
% \end{abstract}

%----------------------------------------------------------------------------------------
%	INTRODUZIONE
%----------------------------------------------------------------------------------------

\chapter{Introduzione}


La specifica della Prova finale (Progetto di Reti Logiche) 2021 richiede di implementare un \textbf{codificatore convoluzionale} usando il linguaggio VHDL.\\
Un codificatore convoluzionale è un dispositivo che tramite l'applicazione di un \textit{codice convoluzionale} codifica uno stream di bit in ingresso in uno stream di bit in uscita ridondante che permette a un dispositivo che legge lo stream codificato di risalire allo stream originale anche in presenza di errori applicando tecniche di \textit{error-correction}.
Codificatori convoluzionali elettronici sono molto comuni nell'ambito delle telecomunicazioni, in quanto conferiscono a una rete un certo grado di robustezza: un dispositivo ricevente può ricostruire il segnale trasmesso, che potrebbe risultare corrotto a causa del rumore sulla linea, senza richiedere un ulteriore invio dell'informazione.

\section{Specifiche}
Nel caso specifico di questo progetto, è richiesto lo sviluppo di un circuito integrato con le seguenti caratteristiche: 
\begin{enumerate}
\item il \textit{codice convoluzionale} ha \textbf{tasso di trasmissione} $\frac{1} {2}$.
\item si interfaccia con una memoria sincrona a word di 8bit e indirizzi a 16bit.
\item lo stream in ingresso è di dimensione $n$ words memorizzate a partire dall'indirizzo \texttt{0x01}.
\item la dimensione dello stream è memorizzata all'indirizzo \texttt{0x00} ed è al massimo di 255 word.
\item il dispositivo viene sempre inizializzato con un segnale di \texttt{reset}.
\item la computazione inizia al segnale di \texttt{start} e termina quando il dispositivo alza il segnale \texttt{done}. Il dispositivo deve essere in grado di gestire computazioni successive senza aver bisogno di un segnale di \texttt{reset}. Si presuppone che il segnale di \texttt{start} rimanga alto durante tutta la computazione e che non possa essere rialzato prima che il segnale di \texttt{done} sia stato riportato a \texttt{0}.
\item il dispositivo deve funzionare con un periodo di clock di almeno \texttt{100ns}
\end{enumerate}

\section{Strumenti}
Il progetto sarà sviluppato in \textbf{VHDL} (VHSIC Hardware Description Language) che permette di descrivere circuiti integrati.
Per la simulazione e la sintesi della scheda il software utilizzato è \textbf{Xilinx Vivado} (\textit{v2021.1}).
Il dispositivo sarà poi implementato su una \textbf{FPGA Artix 7 \texttt{xc7a200tfbg484-1}}.

\section{Esempio}



%----------------------------------------------------------------------------------------
%	ARCHITETTURA
%----------------------------------------------------------------------------------------

\chapter{Architettura}
Il dispositivo è stato implementato come una macchina a stati che controlla un datapath, che si interfaccia con diversi componenti più piccoli. La scelta di dividere il progetto moduli più piccoli è stata presa per non rendere troppo complessa e articolata la gestione del dispositivo nella sua interezza. In questo modo la macchina a stati si limita a gestire la comunicazione e coordinazione dei vari componenti, che eseguono ciascuno una funzione definita anch'essa da una macchina a stati interna.

\section{Serializzatore}

Il \textbf{serializzatore} è il componente addetto alla serializzazione in un flusso continuo di bit dei byte caricati dalla ram.
Il serializzatore si interfaccia, oltre al segnale di \textit{clock} e al segnale di \textit{reset}, con il segnale di ingresso da serializzare \texttt{[input:8bit]} e dal segnale di controllo \textit{start}. Produce in uscita un segnale di \texttt{[output:1bit]} che corrisponde al flusso serializzato del byte in input e un segnale di \textit{done} che indica la fine della serializzazione.

Al segnale di \texttt{start} della serializzazione il componente passa dallo stato \texttt{STOPPED} allo stato attivo. Quando il componente è attivo produce in uscita per \textbf{due clicli di clock} l'\textit{n-esimo} bit del segnale in ingresso, incrementando poi il contatore per produrre in uscita l'\textit{n+1 esimo} bit del byte in ingresso nei prossimi due cicli di clock. La serializzazione termina quando il contatore interno raggiunge il valore \texttt{111}: il registro viene incrementato tornando quindi a \texttt{0} ma il serializzatore torna nello stato \texttt{STOPPED}, che alza il segnale di \texttt{done} a \texttt{1}.

Il flusso in uscita ha periodo di due cicli di clock in quanto al convolutore server produrre due bit sequenzialmente in uscita per ogni bit in entrata. In questo modo la velocità di serializzazione è ridotta della metà ma il convolutore riesce a produrro il flusso risultante sullo stesso ciclo di clock della macchina.

\includegraphics[scale = 0.45]{schematics/serializer.pdf}

\section{Parallelizzatore}
Il \textbf{parallelizzatore} è il componente addetto alla raccolta del flusso in uscita dal convolutore e alla sua memorizzazione in un registro interno. Questo permette di \textit{impacchettare} il flusso d'uscita in byte in modo da essere scritti sulla memoria ram. 
Dato che per questa configurazione del convolutore a \textbf{ogni byte in ingresso} corrispondono \textbf{2 byte in uscita}, questo componente è stato progettato con un registro interno a \textbf{16 bit} in modo da poter memorizzare i 2 byte in uscita dall'elaborazione di un singolo byte e gestire poi il caricamento delle 2 parole sulla RAM. 

Il parallelizzatore si interfaccia con un ingresso \texttt{[input:1bit]} e produce un'uscita \texttt{[output:8bit]}, selezionabile tramite un \textbf{multiplexer}, che seleziona sull'uscita i bit \texttt{[0-7]} e \texttt{[8-15]} del registro interno.

Al segnale di \texttt{start} il componente passa dallo stato \texttt{STOPPED} allo stato \texttt{ACTIVE}. Quando il componente è attivo memorizza il bit di \textbf{ingresso} nell'\textit{n-esimo} bit del registro interno, incrementando poi il contatore per il prossimo ciclo di clock. La parallelizzazione termina quando il contatore interno raggiunge il valore \texttt{1111}: il registro viene incrementato tornando quindi a \texttt{0} e il parallelizzatore torna nello stato \texttt{STOPPED}, tenendo però comunque memorizzati i valori nel registro. A questo punto la macchina a stati entra negli stati di \textit{caricamento in RAM}, dove carica nel registro di uscita in ordine il primo byte e il secondo nel registro di uscita, da cui poi il dato vene caricato sulla memoria.

\includegraphics[scale = 0.45]{schematics/parallelizer.pdf}

%----------------------------------------------------------------------------------------
%	RISULTATI SPERIMENTALI
%----------------------------------------------------------------------------------------

\chapter{Risultati sperimentali}
Il dispositivo progettato è stato sintetizzato e testato con il tool Vivado di Xilinx. Vengono riportate ora le analisi sugli aspetti di sintesi del dispositivo e sui test effettuati su di esso.

\section{Sintesi}
La sintesi è eseguita con un constraint sul periodo di clock di \textbf{100ns} e con una fpga target \textbf{FPGA Artix 7 \texttt{xc7a200tfbg484-1}}.
\subsection{Componenti}
Il report di sintesi riassume l'elenco dei componenti della FPGA utilizzati per sintetizzare il dispositivo.

\begin{verbatim}
+-------------------------+------+-------+------------+-----------+-------+
|        Site Type        | Used | Fixed | Prohibited | Available | Util% |
+-------------------------+------+-------+------------+-----------+-------+
| Slice LUTs*             |  109 |     0 |          0 |    134600 |  0.08 |
|   LUT as Logic          |  109 |     0 |          0 |    134600 |  0.08 |
|   LUT as Memory         |    0 |     0 |          0 |     46200 |  0.00 |
| Slice Registers         |   81 |     0 |          0 |    269200 |  0.03 |
|   Register as Flip Flop |   81 |     0 |          0 |    269200 |  0.03 |
|   Register as Latch     |    0 |     0 |          0 |    269200 |  0.00 |
| F7 Muxes                |    1 |     0 |          0 |     67300 | <0.01 |
| F8 Muxes                |    0 |     0 |          0 |     33650 |  0.00 |
+-------------------------+------+-------+------------+-----------+-------+
\end{verbatim}

Si può notare come tutti i registri utilizzati siano    \textbf{sincroni} (flip flop).

\subsection{Timing}
Il report di timing riassume i parametri della scheda in relazione al segnale di clock

\begin{verbatim}
Slack (MET) :             95.783ns  (required time - arrival time)
  Source:                 DATAPATH0/reg_count_reg[3]/C
                            {rise@0.000ns fall@50.000ns period=100.000ns}
  Destination:            FSM_onehot_cur_state_reg[4]/D
                            {rise@0.000ns fall@50.000ns period=100.000ns}
  Path Group:             clock
  Path Type:              Setup (Max at Slow Process Corner)
  Requirement:            100.000ns  (clock rise@100.000ns - clock rise@0.000ns)
  Data Path Delay:        4.066ns  (logic 1.496ns (36.793%)  route 2.570ns (63.207%))
  Logic Levels:           4  (CARRY4=2 LUT4=1 LUT6=1)
  Clock Path Skew:        -0.145ns (DCD - SCD + CPR)
    Destination Clock Delay (DCD):    2.100ns = ( 102.100 - 100.000 ) 
    Source Clock Delay      (SCD):    2.424ns
    Clock Pessimism Removal (CPR):    0.178ns
  Clock Uncertainty:      0.035ns  ((TSJ^2 + TIJ^2)^1/2 + DJ) / 2 + PE
    Total System Jitter     (TSJ):    0.071ns
    Total Input Jitter      (TIJ):    0.000ns
    Discrete Jitter          (DJ):    0.000ns
    Phase Error              (PE):    0.000ns
\end{verbatim}

Si può notare come lo \textbf{slack} (parametro che indica il tempo tra il delay massimo della logica combinatoria e il prossimo rising-edge del ciclo di clock) sia particolarmente elevato. Questo a grazie al delay della logica combinatoria (\textbf{4.066ns}) che risulta più di un ordine di grandezza inferiore al periodo del ciclo di clock (100ns).
Questo dato indica quindi che la scheda sarebbe in grado di girare a 10 volte la velocità attuale, ovvero con un ciclo di clock di periodo 10ns (100Mhz).

%----------------------------------------------------------------------------------------
%	CONCLUSIONE
%----------------------------------------------------------------------------------------

\chapter{Conclusione}


\end{document}